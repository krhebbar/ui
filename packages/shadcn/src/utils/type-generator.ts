import fs from "fs/promises"
import path from "path"
import { AirdropProjectConfig } from "@/src/types/airdrop-config" // Updated path
import { logger } from "@/src/utils/logger"
import { generateFromOpenAPI, hasOpenAPISpec } from "@/src/utils/openapi-generator"

/**
 * Generate TypeScript definition files for the airdrop project
 */
export async function generateTypeDefinitions(
  cwd: string,
  config: AirdropProjectConfig
): Promise<void> {
  const typesDir = path.join(cwd, "types")
  
  // Ensure types directory exists
  await fs.mkdir(typesDir, { recursive: true })
  
  // Generate airdrop.d.ts
  await generateAirdropTypes(typesDir, config)
  
  // Generate devrev/api.d.ts if openapi.yml exists
  await generateDevRevApiTypes(cwd, typesDir, config)
  
  logger.info("TypeScript definition files generated successfully")
}

/**
 * Generate types/airdrop.d.ts with DevRev objects and external sync units
 */
async function generateAirdropTypes(
  typesDir: string,
  config: AirdropProjectConfig
): Promise<void> {
  const airdropTypesContent = `// Auto-generated from snapin.config.mjs
// Do not edit this file manually

import type { AirdropProjectConfig } from './snapin-config'

// Configuration constants
export const PROJECT_CONFIG: AirdropProjectConfig

// DevRev Object Types
${(config.devrevObjects || []).map(obj => generateDevRevObjectType(obj)).join('\n\n')}

// External System Types
${(config.externalSyncUnits || []).map(unit => generateExternalSyncUnitType(unit)).join('\n\n')}

// Export all DevRev object types
export type DevRevObject = ${config.devrevObjects && config.devrevObjects.length > 0 ? config.devrevObjects.map(obj => toPascalCase(obj)).join(' | ') : 'never'}

// Export all external sync unit types  
export type ExternalSyncUnit = ${config.externalSyncUnits && config.externalSyncUnits.length > 0 ? config.externalSyncUnits.map(unit => toPascalCase(unit)).join(' | ') : 'never'}
`

  const snapinTypesPath = path.join(typesDir, "snapin.d.ts") // Renamed variable and filename
  await fs.writeFile(snapinTypesPath, airdropTypesContent, "utf8")
}

/**
 * Generate DevRev API types from OpenAPI spec if available
 */
async function generateDevRevApiTypes(
  cwd: string,
  typesDir: string,
  config: AirdropProjectConfig
): Promise<void> {
  const devrevTypesDir = path.join(typesDir, "devrev")
  
  // Check if openapi.yml exists and try to generate from it
  if (await hasOpenAPISpec(cwd)) {
    try {
      await generateFromOpenAPI(cwd, config)
      return
    } catch (error) {
      logger.warn(`Failed to generate from OpenAPI spec: ${error}`)
      // Fall back to placeholder types
    }
  }

  // Generate placeholder types as fallback
  await generatePlaceholderApiTypes(devrevTypesDir, config)
}

/**
 * Generate placeholder API types when OpenAPI spec is not available
 */
async function generatePlaceholderApiTypes(
  devrevTypesDir: string,
  config: AirdropProjectConfig
): Promise<void> {
  await fs.mkdir(devrevTypesDir, { recursive: true })

  const apiTypesContent = `// Auto-generated placeholder DevRev API types
// TODO: Generate from OpenAPI spec when available

// Base DevRev API types
export interface DevRevApiResponse<T = any> {
  data: T
  success: boolean
  message?: string
}

export interface DevRevApiError {
  error: string
  message: string
  details?: any
}

// Request/Response types for selected DevRev objects
${(config.devrevObjects || []).map(obj => generateApiTypesForObject(obj)).join('\n\n')}

// Generic CRUD operations
export interface CreateRequest<T> {
  data: Partial<T>
}

export interface UpdateRequest<T> {
  id: string
  data: Partial<T>
}

export interface ListRequest {
  limit?: number
  offset?: number
  filters?: Record<string, any>
}

export interface ListResponse<T> {
  items: T[]
  total: number
  hasMore: boolean
}
`

  const apiTypesPath = path.join(devrevTypesDir, "api.d.ts")
  await fs.writeFile(apiTypesPath, apiTypesContent, "utf8")
}

/**
 * Generate TypeScript type definition for a DevRev object
 */
function generateDevRevObjectType(objectName: string): string {
  const typeName = toPascalCase(objectName)
  
  return `export interface ${typeName} {
  id: string
  created_date: string
  modified_date: string
  created_by_id?: string
  modified_by_id?: string
  // TODO: Add specific fields for ${objectName}
  [key: string]: any
}`
}

/**
 * Generate TypeScript type definition for an external sync unit
 */
function generateExternalSyncUnitType(unitName: string): string {
  const typeName = toPascalCase(unitName)
  
  return `export interface ${typeName} {
  id: string
  external_id: string
  created_date: string
  modified_date: string
  // TODO: Add specific fields for ${unitName}
  [key: string]: any
}`
}

/**
 * Generate API types for a specific DevRev object
 */
function generateApiTypesForObject(objectName: string): string {
  const typeName = toPascalCase(objectName)
  
  return `// ${typeName} API types
export interface Create${typeName}Request extends CreateRequest<${typeName}> {}
export interface Update${typeName}Request extends UpdateRequest<${typeName}> {}
export interface List${typeName}Request extends ListRequest {}
export interface List${typeName}Response extends ListResponse<${typeName}> {}
export interface Get${typeName}Response extends DevRevApiResponse<${typeName}> {}`
}

/**
 * Convert kebab-case or snake_case to PascalCase
 */
function toPascalCase(str: string): string {
  return str
    .split(/[-_]/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('')
}

/**
 * Copy the airdrop-config.ts types to the project types directory
 */
export async function copyConfigTypes(cwd: string): Promise<void> {
  const typesDir = path.join(cwd, "types")
  await fs.mkdir(typesDir, { recursive: true })

  // Generate snapin configuration types directly
  const targetConfigPath = path.join(typesDir, "snapin-config.ts") // Renamed filename
  
  // Generate a complete airdrop configuration types file
  const configTypes = `// Airdrop configuration types
export interface AirdropProjectConfig {
  projectType: "airdrop" | "snap-in";
  syncDirection?: "one-way" | "two-way";
  devrevObjects: string[]; // This is not optional in Zod, can be empty
  externalSyncUnits?: string[];
  externalSystem?: {
    name: string;
    slug: string;
    apiBaseUrl: string;
    testEndpoint: string;
    supportedObjects: string[];
  };
  connection?: {
    type: string; // If connection object exists, type is mandatory
    id: string;
    clientId?: string;
    clientSecret?: string;
    authorize?: { url: string; tokenUrl: string; grantType: string; scope: string; scopeDelimiter: string; };
    refresh?: { url: string; method: string; };
    revoke?: { url: string; method: string; };
    isSubdomain?: boolean;
    subdomain?: string;
    secretTransform?: string;
    tokenVerification?: { url: string; method: string; headers?: Record<string, string>; };
    fields?: Array<{ id: string; name: string; description: string; }>;
    [key: string]: any;
  };
}
`
  await fs.writeFile(targetConfigPath, configTypes, "utf8")
} 