import fs from "fs/promises"
import path from "path"
import { parse as parseYaml } from "yaml"
import { logger } from "@/src/utils/logger"
import { AirdropProjectConfig } from "@/src/types/snapin-config"

interface OpenAPISpec {
  components?: {
    schemas?: Record<string, any>
  }
  paths?: Record<string, any>
}

/**
 * Generate TypeScript definitions from OpenAPI specification
 */
export async function generateFromOpenAPI(
  cwd: string,
  config: AirdropProjectConfig,
  openApiPath?: string
): Promise<void> {
  const specPath = openApiPath || path.join(cwd, "openapi.yml")
  
  try {
    // Check if OpenAPI spec exists
    await fs.access(specPath)
  } catch {
    logger.warn("OpenAPI spec not found, skipping API type generation")
    return
  }

  try {
    const specContent = await fs.readFile(specPath, "utf8")
    const spec = parseYaml(specContent) as OpenAPISpec

    if (!spec.components?.schemas) {
      logger.warn("No schemas found in OpenAPI spec")
      return
    }

    // Generate types for selected DevRev objects
    const apiTypesContent = generateApiTypes(spec, config)
    
    const devrevTypesDir = path.join(cwd, "types", "devrev")
    await fs.mkdir(devrevTypesDir, { recursive: true })
    
    const apiTypesPath = path.join(devrevTypesDir, "api.d.ts")
    await fs.writeFile(apiTypesPath, apiTypesContent, "utf8")
    
    logger.info("Generated API types from OpenAPI specification")
  } catch (error) {
    logger.error(`Failed to generate types from OpenAPI spec: ${error}`)
    throw error
  }
}

/**
 * Generate TypeScript API types from OpenAPI spec
 */
function generateApiTypes(spec: OpenAPISpec, config: AirdropProjectConfig): string {
  const schemas = spec.components?.schemas || {}
  
  let content = `// Auto-generated from OpenAPI specification
// Do not edit this file manually

`

  // Generate base types
  content += generateBaseTypes()
  content += '\n\n'

  // Generate schema types for selected DevRev objects
  const selectedSchemas = Object.entries(schemas).filter(([schemaName]) => 
    config.devrevObjects.some(obj => 
      schemaName.toLowerCase().includes(obj.toLowerCase()) ||
      obj.toLowerCase().includes(schemaName.toLowerCase())
    )
  )

  for (const [schemaName, schema] of selectedSchemas) {
    content += generateSchemaType(schemaName, schema)
    content += '\n\n'
  }

  // Generate API operation types for selected objects
  content += generateApiOperationTypes(config.devrevObjects)

  return content
}

/**
 * Generate base API types
 */
function generateBaseTypes(): string {
  return `// Base DevRev API types
export interface DevRevApiResponse<T = any> {
  data: T
  success: boolean
  message?: string
}

export interface DevRevApiError {
  error: string
  message: string
  details?: any
}

export interface PaginationInfo {
  next_cursor?: string
  prev_cursor?: string
  total_count?: number
}

export interface ListResponse<T> {
  data: T[]
  pagination?: PaginationInfo
}

// Common field types
export interface IdField {
  id: string
}

export interface TimestampFields {
  created_date: string
  modified_date: string
}

export interface UserFields {
  created_by_id?: string
  modified_by_id?: string
}

export interface BaseObject extends IdField, TimestampFields, UserFields {
  [key: string]: any
}`
}

/**
 * Generate TypeScript type from OpenAPI schema
 */
function generateSchemaType(schemaName: string, schema: any): string {
  const typeName = toPascalCase(schemaName)
  
  if (schema.type === 'object' && schema.properties) {
    const properties = Object.entries(schema.properties)
      .map(([propName, propSchema]: [string, any]) => {
        const optional = !schema.required?.includes(propName) ? '?' : ''
        const type = getTypeScriptType(propSchema)
        const description = propSchema.description ? ` // ${propSchema.description}` : ''
        return `  ${propName}${optional}: ${type}${description}`
      })
      .join('\n')

    return `export interface ${typeName} extends BaseObject {
${properties}
}`
  }

  // Handle enum types
  if (schema.enum) {
    const enumValues = schema.enum.map((value: string) => `"${value}"`).join(' | ')
    return `export type ${typeName} = ${enumValues}`
  }

  // Fallback to any type
  return `export type ${typeName} = any`
}

/**
 * Generate API operation types for DevRev objects
 */
function generateApiOperationTypes(devrevObjects: string[]): string {
  let content = '// API Operation Types\n\n'

  for (const objectName of devrevObjects) {
    const typeName = toPascalCase(objectName)
    
    content += `// ${typeName} operations
export interface Create${typeName}Request {
  data: Partial<${typeName}>
}

export interface Create${typeName}Response extends DevRevApiResponse<${typeName}> {}

export interface Update${typeName}Request {
  id: string
  data: Partial<${typeName}>
}

export interface Update${typeName}Response extends DevRevApiResponse<${typeName}> {}

export interface Get${typeName}Request {
  id: string
}

export interface Get${typeName}Response extends DevRevApiResponse<${typeName}> {}

export interface List${typeName}Request {
  limit?: number
  cursor?: string
  filters?: Record<string, any>
}

export interface List${typeName}Response extends DevRevApiResponse<ListResponse<${typeName}>> {}

export interface Delete${typeName}Request {
  id: string
}

export interface Delete${typeName}Response extends DevRevApiResponse<void> {}

`
  }

  return content
}

/**
 * Convert OpenAPI schema type to TypeScript type
 */
function getTypeScriptType(schema: any): string {
  if (!schema) return 'any'

  switch (schema.type) {
    case 'string':
      if (schema.enum) {
        return schema.enum.map((value: string) => `"${value}"`).join(' | ')
      }
      return 'string'
    
    case 'number':
    case 'integer':
      return 'number'
    
    case 'boolean':
      return 'boolean'
    
    case 'array':
      if (schema.items) {
        return `${getTypeScriptType(schema.items)}[]`
      }
      return 'any[]'
    
    case 'object':
      if (schema.properties) {
        const properties = Object.entries(schema.properties)
          .map(([propName, propSchema]: [string, any]) => {
            const optional = !schema.required?.includes(propName) ? '?' : ''
            const type = getTypeScriptType(propSchema)
            return `${propName}${optional}: ${type}`
          })
          .join('; ')
        return `{ ${properties} }`
      }
      return 'Record<string, any>'
    
    default:
      if (schema.$ref) {
        const refParts = schema.$ref.split('/')
        const typeName = refParts[refParts.length - 1]
        return toPascalCase(typeName)
      }
      return 'any'
  }
}

/**
 * Convert string to PascalCase
 */
function toPascalCase(str: string): string {
  return str
    .split(/[-_\s]/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('')
}

/**
 * Check if OpenAPI specification exists
 */
export async function hasOpenAPISpec(cwd: string): Promise<boolean> {
  try {
    await fs.access(path.join(cwd, "openapi.yml"))
    return true
  } catch {
    return false
  }
} 