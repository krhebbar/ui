import fs from "fs/promises"
import path from "path"
import { AirdropProjectConfig } from "@/src/types/snapin-config" // Updated path
import { logger } from "@/src/utils/logger"
import { generateFromOpenAPI, hasOpenAPISpec } from "@/src/utils/generators/openapi-generator"

/**
 * Generate TypeScript definition files for the airdrop project
 */
export async function generateTypeDefinitions(
  cwd: string,
  config: AirdropProjectConfig
): Promise<void> {
  const typesDir = path.join(cwd, "code", "types")
  
  // Ensure types directory exists
  await fs.mkdir(typesDir, { recursive: true })
  
  // Generate airdrop.d.ts
  await generateAirdropTypes(typesDir, config)
  
  // Generate devrev/api.d.ts if openapi.yml exists
  await generateDevRevApiTypes(cwd, typesDir, config)
  
  logger.info("TypeScript definition files generated successfully")
}

/**
 * Generate types/airdrop.d.ts with DevRev objects and external sync units
 */
async function generateAirdropTypes(
  typesDir: string,
  config: AirdropProjectConfig
): Promise<void> {
  const airdropTypesContent = `// Auto-generated from snapin.config.mjs
// Do not edit this file manually

import type { AirdropProjectConfig } from './snapin-config'

// Configuration constants
export const PROJECT_CONFIG: AirdropProjectConfig

// DevRev Object Types
${(config.devrevObjects || []).map(obj => generateDevRevObjectType(obj)).join('\n\n')}

// External System Types
${(config.externalSyncUnits || []).map(unit => generateExternalSyncUnitType(unit)).join('\n\n')}

// Export all DevRev object types
export type DevRevObject = ${config.devrevObjects && config.devrevObjects.length > 0 ? config.devrevObjects.map(obj => toPascalCase(obj)).join(' | ') : 'never'}

// Export all external sync unit types  
export type ExternalSyncUnit = ${config.externalSyncUnits && config.externalSyncUnits.length > 0 ? config.externalSyncUnits.map(unit => toPascalCase(unit)).join(' | ') : 'never'}
`

  const snapinTypesPath = path.join(typesDir, "snapin.d.ts") // Renamed variable and filename
  await fs.writeFile(snapinTypesPath, airdropTypesContent, "utf8")
}

/**
 * Generate DevRev API types from OpenAPI spec if available
 */
async function generateDevRevApiTypes(
  cwd: string,
  typesDir: string,
  config: AirdropProjectConfig
): Promise<void> {
  const devrevTypesDir = path.join(typesDir, "devrev")
  
  // Check if openapi.yml exists and try to generate from it
  if (await hasOpenAPISpec(cwd)) {
    try {
      await generateFromOpenAPI(cwd, config)
      return
    } catch (error) {
      logger.warn(`Failed to generate from OpenAPI spec: ${error}`)
      // Fall back to placeholder types
    }
  }

  // Generate placeholder types as fallback
  await generatePlaceholderApiTypes(devrevTypesDir, config)
}

/**
 * Generate placeholder API types when OpenAPI spec is not available
 */
async function generatePlaceholderApiTypes(
  devrevTypesDir: string,
  config: AirdropProjectConfig
): Promise<void> {
  await fs.mkdir(devrevTypesDir, { recursive: true })

  const apiTypesContent = `// Auto-generated placeholder DevRev API types
// TODO: Generate from OpenAPI spec when available

// Base DevRev API types
export interface DevRevApiResponse<T = any> {
  data: T
  success: boolean
  message?: string
}

export interface DevRevApiError {
  error: string
  message: string
  details?: any
}

// Request/Response types for selected DevRev objects
${(config.devrevObjects || []).map(obj => generateApiTypesForObject(obj)).join('\n\n')}

// Generic CRUD operations
export interface CreateRequest<T> {
  data: Partial<T>
}

export interface UpdateRequest<T> {
  id: string
  data: Partial<T>
}

export interface ListRequest {
  limit?: number
  offset?: number
  filters?: Record<string, any>
}

export interface ListResponse<T> {
  items: T[]
  total: number
  hasMore: boolean
}
`

  const apiTypesPath = path.join(devrevTypesDir, "api.d.ts")
  await fs.writeFile(apiTypesPath, apiTypesContent, "utf8")
}

/**
 * Generate TypeScript type definition for a DevRev object
 */
function generateDevRevObjectType(objectName: string): string {
  const typeName = toPascalCase(objectName)
  
  return `export interface ${typeName} {
  id: string
  created_date: string
  modified_date: string
  created_by_id?: string
  modified_by_id?: string
  // TODO: Add specific fields for ${objectName}
  [key: string]: any
}`
}

/**
 * Generate TypeScript type definition for an external sync unit
 */
function generateExternalSyncUnitType(unitName: string): string {
  const typeName = toPascalCase(unitName)
  
  return `export interface ${typeName} {
  id: string
  external_id: string
  created_date: string
  modified_date: string
  // TODO: Add specific fields for ${unitName}
  [key: string]: any
}`
}

/**
 * Generate API types for a specific DevRev object
 */
function generateApiTypesForObject(objectName: string): string {
  const typeName = toPascalCase(objectName)
  
  return `// ${typeName} API types
export interface Create${typeName}Request extends CreateRequest<${typeName}> {}
export interface Update${typeName}Request extends UpdateRequest<${typeName}> {}
export interface List${typeName}Request extends ListRequest {}
export interface List${typeName}Response extends ListResponse<${typeName}> {}
export interface Get${typeName}Response extends DevRevApiResponse<${typeName}> {}`
}

/**
 * Convert kebab-case or snake_case to PascalCase
 */
function toPascalCase(str: string): string {
  return str
    .split(/[-_]/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('')
}

/**
 * Copy the snapin configuration types to the project types directory
 * This generates a self-contained schema for the cloned project
 */
export async function copyConfigTypes(cwd: string): Promise<void> {
  const typesDir = path.join(cwd, "code", "types")
  await fs.mkdir(typesDir, { recursive: true })

  // Generate snapin configuration types - self-contained schema
  const targetConfigPath = path.join(typesDir, "snapin-config.ts")
  
  // Generate a clean, self-contained schema
  const configTypes = `// Airdrop configuration types
// This file is auto-generated - do not edit manually

import { z } from "zod"

// Connection type schemas
export const oAuth2ConnectionSchema = z.object({
  type: z.literal("oauth2"),
  id: z.string(),
  clientId: z.string(),
  clientSecret: z.string(),
  headers: z.record(z.string()).optional(),
  authorize: z.object({
    url: z.string(),
    tokenUrl: z.string(),
    grantType: z.string().default("authorization_code"),
    scope: z.string(),
    scopeDelimiter: z.string().default(" "),
  }),
  refresh: z.object({
    url: z.string(),
    method: z.string().default("POST"),
  }),
  revoke: z.object({
    url: z.string(),
    method: z.string().default("POST"),
  }),
  tokenEnvVarName: z.string().optional(),
})

export const secretConnectionSchema = z.object({
  type: z.literal("secret"),
  id: z.string(),
  isSubdomain: z.boolean().optional(),
  subdomain: z.string().optional(),
  secretTransform: z.string(),
  headers: z.record(z.string()).optional(),
  tokenVerification: z.object({
    url: z.string(),
    method: z.string().default("GET"),
    headers: z.record(z.string()).optional(),
  }),
  fields: z.array(
    z.object({
      id: z.string(),
      name: z.string(),
      description: z.string(),
    })
  ).optional(),
  tokenEnvVarName: z.string().optional(),
})

export const connectionSchema = z.union([oAuth2ConnectionSchema, secretConnectionSchema])

// External system schema
export const externalSystemSchema = z.object({
  name: z.string(),
  slug: z.string(),
  apiBaseUrl: z.string(),
  externalObjects: z.array(z.string()),
  accessMethod: z.enum(["sdk", "api"]),
  isComplete: z.boolean().optional(),
  documentationUrl: z.string().optional(),
  sdkBaseUrl: z.string().optional(),
  sdkPackages: z.array(z.string()).optional(),
  connection: connectionSchema,
})

// Main airdrop config schema
export const airdropConfigSchema = z.object({
  projectType: z.enum(["airdrop", "snap-in"]),
  syncDirection: z.enum(["one-way", "two-way"]).optional(),
  devrevObjects: z.array(z.string()),
  externalSyncUnits: z.array(z.string()).optional(),
  externalSystem: externalSystemSchema.optional(),
  devrevPatEnvVarName: z.string().optional(), 
  devrevOrgEnvVarName: z.string().optional(),
})

// Export types
export type OAuth2Connection = z.infer<typeof oAuth2ConnectionSchema>
export type SecretConnection = z.infer<typeof secretConnectionSchema>
export type Connection = z.infer<typeof connectionSchema>
export type ExternalSystem = z.infer<typeof externalSystemSchema>
export type AirdropProjectConfig = z.infer<typeof airdropConfigSchema>

// Supported DevRev object types
export const SUPPORTED_DEVREV_OBJECTS = [
  "account",
  "airdrop_authorization_policy", 
  "airdrop_platform_group",
  "article",
  "capability",
  "channel", 
  "comment",
  "component",
  "conversation",
  "custom_link",
  "custom_part",
  "devu",
  "directory",
  "dm",
  "enhancement",
  "feature",
  "group",
  "incident",
  "issue",
  "link",
  "linkable",
  "meeting",
  "microservice",
  "object_member",
  "opportunity",
  "product",
  "revu",
  "runnable",
  "sysu",
  "tag",
  "task",
  "test_custom_type",
  "ticket",
] as const

export type SupportedDevRevObject = typeof SUPPORTED_DEVREV_OBJECTS[number]
`
  await fs.writeFile(targetConfigPath, configTypes, "utf8")
} 